---
phase: 03-reporter-database-annotation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/data/reporters.ts
  - src/data/index.ts
  - tests/data/reporters.test.ts
autonomous: true

must_haves:
  truths:
    - "Developer can load reporter database from reporters-db with 1200+ reporters"
    - "Reporter lookup is O(1) fast using Map-based indexing"
    - "Library works in degraded mode without reporter data loaded"
  artifacts:
    - path: "src/data/reporters.ts"
      provides: "Lazy-loadable reporter database with Map indexing"
      min_lines: 100
      exports: ["loadReporters", "getReportersSync", "findReportersByAbbreviation"]
    - path: "src/data/index.ts"
      provides: "Data layer exports"
      exports: ["*"]
    - path: "tests/data/reporters.test.ts"
      provides: "Reporter loading and lookup tests"
      min_lines: 60
  key_links:
    - from: "src/data/reporters.ts"
      to: "reporters-db JSON data"
      via: "Dynamic import with assert type json"
      pattern: "import.*reporters\\.json.*assert.*type.*json"
    - from: "src/data/reporters.ts"
      to: "Map<string, ReporterEntry[]>"
      via: "Lowercase key normalization for O(1) lookup"
      pattern: "Map<string.*ReporterEntry"
---

<objective>
Implement lazy-loadable reporter database integration with Map-based O(1) lookup, enabling validation against reporters-db while maintaining degraded mode compatibility.

Purpose: Enables Phase 3 citation validation against 1200+ reporters without bloating core bundle
Output: Reporter loader, Map-based indexing, lazy loading with degraded mode
</objective>

<execution_context>
@/Users/medelman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medelman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-reporter-database-annotation/03-CONTEXT.md
@.planning/phases/03-reporter-database-annotation/03-RESEARCH.md
@src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define ReporterEntry type and database structure</name>
  <files>src/data/reporters.ts, src/data/index.ts</files>
  <action>
Create `src/data/reporters.ts` with TypeScript types matching reporters-db structure:

```typescript
export interface ReporterEntry {
  abbreviation: string          // Canonical abbreviation
  name: string                  // Full reporter name
  start: string | null          // Start date (ISO 8601)
  end: string | null            // End date (ISO 8601)
  variations: string[]          // Variant forms
  cite_type: string             // 'state' | 'federal' | 'specialty' | 'neutral'
  jurisdiction?: string         // Optional jurisdiction
}

export interface ReportersDatabase {
  byAbbreviation: Map<string, ReporterEntry[]>  // Fast O(1) lookup
  all: ReporterEntry[]                          // All reporters
}
```

Add package.json export for data layer:
```json
"./data": {
  "types": "./dist/data/index.d.ts",
  "import": "./dist/data/index.mjs",
  "require": "./dist/data/index.cjs"
}
```

Create `src/data/index.ts` with re-export: `export * from "./reporters"`

Add JSDoc explaining lazy loading and degraded mode.

IMPORTANT: DO NOT import reporters.json yet (Task 2). This task only defines types.
  </action>
  <verify>
Run `npm run typecheck` - no errors
Check that ReporterEntry and ReportersDatabase are exported from src/data/index.ts
  </verify>
  <done>ReporterEntry type exists, ReportersDatabase structure defined, data layer exported from package.json</done>
</task>

<task type="auto">
  <name>Task 2: Implement lazy loading with Map-based indexing</name>
  <files>src/data/reporters.ts</files>
  <action>
Implement lazy loading functions in `src/data/reporters.ts`:

```typescript
let cached: ReportersDatabase | null = null

export async function loadReporters(): Promise<ReportersDatabase> {
  if (cached) return cached

  // Dynamic import prevents loading until explicitly requested
  const data = await import('reporters-db/data/reporters.json', {
    assert: { type: 'json' }
  })

  const byAbbreviation = new Map<string, ReporterEntry[]>()

  // Build fast lookup index with lowercase normalization
  for (const reporter of data.default || data) {
    const key = reporter.abbreviation.toLowerCase()
    if (!byAbbreviation.has(key)) {
      byAbbreviation.set(key, [])
    }
    byAbbreviation.get(key)!.push(reporter)

    // Index all variations for fuzzy matching
    for (const variant of reporter.variations || []) {
      const variantKey = variant.toLowerCase()
      if (!byAbbreviation.has(variantKey)) {
        byAbbreviation.set(variantKey, [])
      }
      byAbbreviation.get(variantKey)!.push(reporter)
    }
  }

  cached = { byAbbreviation, all: data.default || data }
  return cached
}

export function getReportersSync(): ReportersDatabase | null {
  return cached  // null if not loaded yet (degraded mode)
}

export async function findReportersByAbbreviation(
  abbr: string
): Promise<ReporterEntry[]> {
  const db = await loadReporters()
  return db.byAbbreviation.get(abbr.toLowerCase()) ?? []
}
```

Follow RESEARCH.md Pattern 1 (Lazy-Loadable Data Chunk Strategy). Use Map for O(1) lookup. Cache result after first load.

IMPORTANT: Degraded mode means getReportersSync() returns null if not loaded - this is expected and correct.
  </action>
  <verify>
Run `npm run typecheck` - no errors
Check that loadReporters() uses dynamic import
Verify Map is used for byAbbreviation (not Object or Array)
  </verify>
  <done>Lazy loading implemented, Map-based indexing working, degraded mode supported via getReportersSync()</done>
</task>

<task type="auto">
  <name>Task 3: Test reporter loading and lookup performance</name>
  <files>tests/data/reporters.test.ts</files>
  <action>
Create `tests/data/reporters.test.ts` with Vitest tests:

**Test 1: Lazy loading (reporters not loaded initially)**
- Assert: `getReportersSync() === null` before loadReporters() called
- After calling `loadReporters()`: `getReportersSync() !== null`

**Test 2: Reporter lookup by abbreviation**
- Load reporters, find "F.2d" (Federal Reporter, Second Series)
- Assert: Returns array with at least 1 entry
- Check: entry.name includes "Federal Reporter"

**Test 3: Variant form lookup**
- Look up reporter by variant form (not canonical abbreviation)
- Assert: Returns matching ReporterEntry

**Test 4: Unknown reporter returns empty array**
- Look up "NONEXISTENT"
- Assert: Returns empty array [] (not undefined, not error)

**Test 5: Case-insensitive lookup**
- Look up "f.2d" (lowercase) and "F.2D" (uppercase)
- Assert: Both return same result

**Test 6: Performance - O(1) lookup**
- Load reporters, time 1000 lookups
- Assert: Total time < 50ms (should be ~1-2ms for Map lookups)

Use Vitest's `describe`, `it`, `expect` syntax. Test degraded mode explicitly.
  </action>
  <verify>
Run `npm test tests/data/reporters.test.ts` - all tests pass
Check that test covers degraded mode (getReportersSync returns null initially)
Verify performance test completes in <50ms
  </verify>
  <done>Reporter tests pass, degraded mode verified, O(1) lookup performance confirmed</done>
</task>

</tasks>

<verification>
- [ ] Run `npm run typecheck` - no errors
- [ ] Run `npm test tests/data/reporters.test.ts` - all tests pass
- [ ] Check that `getReportersSync()` returns null before loading (degraded mode)
- [ ] Verify `loadReporters()` uses dynamic import (not static import)
- [ ] Confirm Map-based indexing for O(1) lookup
</verification>

<success_criteria>
Plan succeeds when:
1. Developer can call `loadReporters()` to load reporters-db data
2. Reporter lookup by abbreviation works in O(1) time via Map
3. Library works in degraded mode (getReportersSync returns null before loading)
4. All variations (including variant forms) are indexed for lookup
5. Tests validate lazy loading, degraded mode, and performance
</success_criteria>

<output>
After completion, create `.planning/phases/03-reporter-database-annotation/03-01-SUMMARY.md`
</output>
