---
phase: 03-reporter-database-annotation
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/extract/validation.ts
  - src/extract/index.ts
  - tests/extract/validation.test.ts
autonomous: true

must_haves:
  truths:
    - "Citations validated against reporter database have adjusted confidence scores"
    - "Unmatched reporters flagged with warning, not silently dropped"
    - "Validation works in degraded mode (returns citations without reporter match)"
    - "Ambiguous reporter abbreviations handled with fractional confidence"
  artifacts:
    - path: "src/extract/validation.ts"
      provides: "Citation validation against reporter database with confidence scoring"
      min_lines: 80
      exports: ["validateAndScore", "extractWithValidation"]
    - path: "tests/extract/validation.test.ts"
      provides: "Validation tests for degraded mode and confidence scoring"
      min_lines: 60
  key_links:
    - from: "src/extract/validation.ts"
      to: "src/data/reporters.ts"
      via: "findReportersByAbbreviation import"
      pattern: "import.*findReportersByAbbreviation.*from.*data"
    - from: "src/extract/validation.ts"
      to: "Confidence scoring logic"
      via: "Boost on match (+0.2), penalty on miss (-0.3)"
      pattern: "confidence.*\\+.*0\\.2|confidence.*-.*0\\.3"
---

<objective>
Implement citation validation against reporter database with confidence scoring adjustments, supporting degraded mode when database not loaded.

Purpose: Enhances Phase 2 extraction with reporter database validation while maintaining backward compatibility
Output: Validation layer, confidence scoring, degraded mode support
</objective>

<execution_context>
@/Users/medelman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medelman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-reporter-database-annotation/03-CONTEXT.md
@.planning/phases/03-reporter-database-annotation/03-RESEARCH.md
@.planning/phases/03-reporter-database-annotation/03-01-SUMMARY.md
@src/extract/index.ts
@src/types/citation.ts
@src/data/reporters.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement confidence scoring with reporter validation</name>
  <files>src/extract/validation.ts, src/extract/index.ts</files>
  <action>
Create `src/extract/validation.ts` with validation logic:

```typescript
import type { Citation } from '../types/citation'
import type { ReportersDatabase, ReporterEntry } from '../data/reporters'
import { getReportersSync } from '../data/reporters'

export interface ConfidenceScoringOptions {
  reporterMatchBoost: number      // Default: +0.2
  reporterMissPenalty: number     // Default: -0.3
  ambiguityPenalty: number        // Default: -0.1 per extra match
}

// Extend Citation type with reporter validation fields
export interface ValidatedCitation extends Citation {
  reporterMatch?: ReporterEntry | null
  reporterMatches?: ReporterEntry[]  // For ambiguous matches
}

export async function validateAndScore(
  citation: Citation,
  reportersDb: ReportersDatabase | null,
  options: Partial<ConfidenceScoringOptions> = {}
): Promise<ValidatedCitation> {
  const opts: ConfidenceScoringOptions = {
    reporterMatchBoost: 0.2,
    reporterMissPenalty: -0.3,
    ambiguityPenalty: -0.1,
    ...options,
  }

  // Only validate case citations (others don't have reporters)
  if (!reportersDb || citation.type !== 'case') {
    return citation
  }

  let adjustedConfidence = citation.confidence

  if ('reporter' in citation && citation.reporter) {
    const matches = reportersDb.byAbbreviation.get(citation.reporter.toLowerCase()) ?? []

    if (matches.length === 0) {
      // No match: penalize confidence, flag as unmatched
      adjustedConfidence = Math.max(0, adjustedConfidence + opts.reporterMissPenalty)
      return {
        ...citation,
        confidence: adjustedConfidence,
        reporterMatch: null,
        warnings: [
          ...(citation.warnings ?? []),
          {
            level: 'warning',
            message: `Reporter "${citation.reporter}" not found in database`,
            position: { start: citation.span.originalStart, end: citation.span.originalEnd },
          },
        ],
      }
    } else if (matches.length === 1) {
      // Exact match: boost confidence
      adjustedConfidence = Math.min(1.0, adjustedConfidence + opts.reporterMatchBoost)
      return {
        ...citation,
        confidence: adjustedConfidence,
        reporterMatch: matches[0],
      }
    } else {
      // Ambiguous: fractional confidence
      const penalty = opts.ambiguityPenalty * (matches.length - 1)
      adjustedConfidence = Math.max(0, adjustedConfidence + penalty)
      return {
        ...citation,
        confidence: adjustedConfidence,
        reporterMatches: matches,
        warnings: [
          ...(citation.warnings ?? []),
          {
            level: 'warning',
            message: `Ambiguous reporter: ${matches.map(m => m.name).join(', ')}`,
            position: { start: citation.span.originalStart, end: citation.span.originalEnd },
          },
        ],
      }
    }
  }

  return citation
}

// High-level API: extract with optional validation
export async function extractWithValidation(
  text: string,
  options: { validate?: boolean } = {}
): Promise<ValidatedCitation[]> {
  const { extract } = await import('./index')
  const citations = await extract(text)

  if (!options.validate) {
    // Degraded mode: no validation
    return citations
  }

  const reportersDb = getReportersSync()
  if (!reportersDb) {
    // Database not loaded: return citations with warning
    return citations.map(c => ({
      ...c,
      reporterMatch: null,
      warnings: [
        ...(c.warnings ?? []),
        {
          level: 'info',
          message: 'Reporter database not loaded; validation skipped',
          position: { start: c.span.originalStart, end: c.span.originalEnd },
        },
      ],
    }))
  }

  return Promise.all(citations.map(c => validateAndScore(c, reportersDb)))
}
```

Follow RESEARCH.md Pattern 3 (Confidence Scoring with Reporter Match). Support degraded mode (database null). Never throw on missing reporter.

Re-export from `src/extract/index.ts`: `export { validateAndScore, extractWithValidation } from "./validation"`
  </action>
  <verify>
Run `npm run typecheck` - no errors
Check that validateAndScore never throws (returns low confidence instead)
Verify degraded mode returns citations without validation
  </verify>
  <done>Validation logic implemented, confidence scoring working, degraded mode supported</done>
</task>

<task type="auto">
  <name>Task 2: Test validation with degraded mode and confidence adjustments</name>
  <files>tests/extract/validation.test.ts</files>
  <action>
Create `tests/extract/validation.test.ts` with Vitest tests:

**Test 1: Degraded mode (no database loaded)**
- Call `extractWithValidation(text, { validate: false })`
- Assert: Citations returned without reporterMatch
- Check: No errors thrown

**Test 2: Exact reporter match boosts confidence**
- Load reporters database
- Create case citation with known reporter (e.g., "F.2d")
- Validate and score
- Assert: Confidence increased by ~0.2 (boost)
- Check: reporterMatch is set

**Test 3: Unknown reporter penalizes confidence**
- Citation with unknown reporter "FAKE"
- Validate and score
- Assert: Confidence decreased by ~0.3 (penalty)
- Check: reporterMatch is null
- Verify: Warning added to citation

**Test 4: Ambiguous reporter fractional confidence**
- Citation with abbreviation matching multiple reporters
- Validate and score
- Assert: Confidence reduced proportionally
- Check: reporterMatches array populated

**Test 5: Non-case citations skip validation**
- Statute citation (no reporter field)
- Validate and score
- Assert: Citation returned unchanged (no confidence adjustment)

**Test 6: Database not loaded returns info warning**
- Don't call loadReporters()
- Call extractWithValidation with validate: true
- Assert: Citations have info-level warning about database not loaded
- Check: No errors thrown (degraded mode graceful)

Use Vitest's `describe`, `it`, `expect`. Test degraded mode thoroughly.
  </action>
  <verify>
Run `npm test tests/extract/validation.test.ts` - all tests pass
Check that degraded mode test validates database-not-loaded case
Verify confidence scoring matches documented thresholds
  </verify>
  <done>Validation tests pass, degraded mode verified, confidence scoring validated</done>
</task>

</tasks>

<verification>
- [ ] Run `npm run typecheck` - no errors
- [ ] Run `npm test tests/extract/validation.test.ts` - all tests pass
- [ ] Check that validation works in degraded mode (no errors)
- [ ] Verify confidence scoring: +0.2 boost, -0.3 penalty
- [ ] Confirm unmatched reporters flagged, not dropped
</verification>

<success_criteria>
Plan succeeds when:
1. Citations validated against reporter database get adjusted confidence scores
2. Unmatched reporters are flagged with warnings, not silently dropped
3. Library works in degraded mode (returns citations without database)
4. Ambiguous matches handled with fractional confidence
5. Tests validate all scoring scenarios and degraded mode
</success_criteria>

<output>
After completion, create `.planning/phases/03-reporter-database-annotation/03-03-SUMMARY.md`
</output>
