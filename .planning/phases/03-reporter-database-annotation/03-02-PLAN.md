---
phase: 03-reporter-database-annotation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/annotate/types.ts
  - src/annotate/annotate.ts
  - src/annotate/index.ts
  - tests/annotate/annotate.test.ts
autonomous: true

must_haves:
  truths:
    - "Developer can annotate citations with callback function for custom markup"
    - "Developer can annotate citations with template (before/after strings)"
    - "Annotation preserves position tracking for both original and cleaned text"
    - "HTML entities are auto-escaped by default to prevent XSS"
  artifacts:
    - path: "src/annotate/types.ts"
      provides: "Annotation API types (AnnotationOptions, AnnotationResult)"
      exports: ["AnnotationOptions", "AnnotationResult"]
    - path: "src/annotate/annotate.ts"
      provides: "Main annotation function with callback and template modes"
      min_lines: 120
      exports: ["annotate"]
    - path: "tests/annotate/annotate.test.ts"
      provides: "Annotation tests with position tracking"
      min_lines: 80
  key_links:
    - from: "src/annotate/annotate.ts"
      to: "src/types/citation.ts"
      via: "Citation import for type safety"
      pattern: "import.*Citation.*from.*types"
    - from: "src/annotate/annotate.ts"
      to: "escapeHtmlEntities function"
      via: "Auto-escaping with secure defaults"
      pattern: "function escapeHtmlEntities"
---

<objective>
Implement position-aware citation annotation API supporting both callback and template modes with auto-escaping, leveraging Phase 2's dual-span position tracking.

Purpose: Enables developers to mark up citations in text for UI highlighting, linking, or processing
Output: Annotation types, annotate() function with callback/template modes, HTML entity escaping
</objective>

<execution_context>
@/Users/medelman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medelman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-reporter-database-annotation/03-CONTEXT.md
@.planning/phases/03-reporter-database-annotation/03-RESEARCH.md
@src/types/citation.ts
@src/types/span.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define annotation types and options</name>
  <files>src/annotate/types.ts, src/annotate/index.ts</files>
  <action>
Create `src/annotate/types.ts` with annotation API types:

```typescript
import type { Citation } from '../types/citation'

export interface AnnotationOptions {
  /** Apply annotations to cleaned text (true) or original text (false) */
  useCleanText?: boolean
  /** Auto-escape HTML entities (default: true for XSS protection) */
  autoEscape?: boolean
  /** Callback for custom annotation logic */
  callback?: (citation: Citation, surrounding: string) => string
  /** Template mode: before/after markup strings */
  template?: {
    before: string  // e.g., '<mark data-type="case">'
    after: string   // e.g., '</mark>'
  }
}

export interface AnnotationResult {
  /** Annotated text with markup inserted */
  text: string
  /** Position mapping from original to annotated positions */
  positionMap: Map<number, number>
  /** Citations that couldn't be annotated (overlaps, errors) */
  skipped: Citation[]
}
```

Create `src/annotate/index.ts` with re-exports: `export * from "./types"` and `export * from "./annotate"`

Add JSDoc explaining callback vs template modes, auto-escaping defaults.

IMPORTANT: Auto-escape defaults to TRUE for security (opt-out, not opt-in). Document XSS risk if disabled.
  </action>
  <verify>
Run `npm run typecheck` - no errors
Check that AnnotationOptions and AnnotationResult are exported from src/annotate/index.ts
Verify autoEscape is optional with default true
  </verify>
  <done>Annotation types defined, API exported, security defaults documented</done>
</task>

<task type="auto">
  <name>Task 2: Implement annotation function with dual-mode support</name>
  <files>src/annotate/annotate.ts</files>
  <action>
Implement annotation in `src/annotate/annotate.ts`:

```typescript
import type { Citation } from '../types/citation'
import type { AnnotationOptions, AnnotationResult } from './types'

export function annotate(
  text: string,
  citations: Citation[],
  options: AnnotationOptions = {}
): AnnotationResult {
  const {
    useCleanText = false,
    autoEscape = true,  // Secure by default
    template,
    callback,
  } = options

  // Sort reverse to avoid position shifts invalidating subsequent annotations
  const sorted = [...citations].sort((a, b) => {
    const aPos = useCleanText ? a.span.cleanStart : a.span.originalStart
    const bPos = useCleanText ? b.span.cleanStart : b.span.originalStart
    return bPos - aPos  // Reverse for backward iteration
  })

  let result = text
  let shift = 0
  const positionMap = new Map<number, number>()

  for (const citation of sorted) {
    const start = useCleanText ? citation.span.cleanStart : citation.span.originalStart
    const end = useCleanText ? citation.span.cleanEnd : citation.span.originalEnd

    let markup = ''

    if (callback) {
      // Callback mode: developer provides full logic
      const surrounding = text.substring(
        Math.max(0, start - 30),
        Math.min(text.length, end + 30)
      )
      markup = callback(citation, surrounding)
    } else if (template) {
      // Template mode: simple before/after wrapping
      const citationText = text.substring(start, end)
      const escaped = autoEscape ? escapeHtmlEntities(citationText) : citationText
      markup = template.before + escaped + template.after
    } else {
      continue  // No annotation specified
    }

    // Insert annotation (working backwards preserves positions)
    const adjustedStart = start + shift
    const adjustedEnd = end + shift
    result = result.slice(0, adjustedStart) + markup + result.slice(adjustedEnd)

    shift += markup.length - (end - start)
    positionMap.set(start, adjustedStart)
  }

  return { text: result, positionMap, skipped: [] }
}

// HTML entity escaping for XSS protection
function escapeHtmlEntities(text: string): string {
  const map: Record<string, string> = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '/': '&#x2F;',
  }
  return text.replace(/[&<>"'\/]/g, (char) => map[char])
}
```

Follow RESEARCH.md Pattern 2 (Annotation with Dual-Span Position Tracking). Process citations in reverse order to avoid position invalidation. Support both callback and template modes.

IMPORTANT: Do NOT handle overlapping citations yet (Phase 3 scope is basic annotation; overlap deduplication is Phase 4).
  </action>
  <verify>
Run `npm run typecheck` - no errors
Check that annotate() supports both callback and template modes
Verify escapeHtmlEntities() is implemented
  </verify>
  <done>Annotation function working, dual-mode support complete, HTML escaping implemented</done>
</task>

<task type="auto">
  <name>Task 3: Test annotation with position tracking and auto-escaping</name>
  <files>tests/annotate/annotate.test.ts</files>
  <action>
Create `tests/annotate/annotate.test.ts` with Vitest tests:

**Test 1: Template mode - simple before/after wrapping**
- Input: "See 500 F.2d 123" with case citation at positions 4-16
- Template: `{ before: '<cite>', after: '</cite>' }`
- Assert: Result is "See <cite>500 F.2d 123</cite>"

**Test 2: Callback mode - custom annotation logic**
- Input: Same text
- Callback: `(c) => \`<a href="/cases/\${c.volume}-\${c.page}">\${c.matchedText}</a>\``
- Assert: Result contains hyperlink with volume and page

**Test 3: Auto-escaping enabled (default)**
- Input: Text with HTML entities: "See <script>alert(1)</script> F.2d 123"
- Template mode with autoEscape: true
- Assert: Output contains "&lt;script&gt;" (escaped, not raw "<script>")

**Test 4: Auto-escaping disabled (opt-out)**
- Input: Same malicious text
- Template with autoEscape: false
- Assert: Output contains raw "<script>" (NOT ESCAPED - document this risk)

**Test 5: Multiple citations annotated**
- Input: "500 F.2d 123 and 400 F.3d 456"
- Two case citations
- Assert: Both are annotated correctly

**Test 6: Position map tracks shifts**
- After annotation, check positionMap
- Assert: positionMap.get(4) reflects position shift from inserted markup

**Test 7: useCleanText mode**
- Provide citation with both cleanStart and originalStart
- useCleanText: true
- Assert: Uses cleanStart/cleanEnd positions

Use Vitest's `describe`, `it`, `expect`. Test security (auto-escaping) explicitly.
  </action>
  <verify>
Run `npm test tests/annotate/annotate.test.ts` - all tests pass
Check that auto-escaping test prevents XSS
Verify position map test validates shift tracking
  </verify>
  <done>Annotation tests pass, auto-escaping validated, position tracking verified</done>
</task>

</tasks>

<verification>
- [ ] Run `npm run typecheck` - no errors
- [ ] Run `npm test tests/annotate/annotate.test.ts` - all tests pass
- [ ] Check that auto-escaping is ON by default (security)
- [ ] Verify both callback and template modes work
- [ ] Confirm position map tracks annotation shifts
</verification>

<success_criteria>
Plan succeeds when:
1. Developer can use callback mode for custom annotation logic
2. Developer can use template mode for simple before/after wrapping
3. Auto-escaping prevents XSS injection by default
4. Position tracking works for both original and cleaned text
5. Tests validate all annotation modes and security
</success_criteria>

<output>
After completion, create `.planning/phases/03-reporter-database-annotation/03-02-SUMMARY.md`
</output>
